"use strict";(self.webpackChunkreality_toolkit_docs=self.webpackChunkreality_toolkit_docs||[]).push([[2075],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=o.createContext({}),u=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=u(e.components);return o.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||r;return n?o.createElement(m,a(a({ref:t},l),{},{components:n})):o.createElement(m,a({ref:t},l))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:i,a[1]=s;for(var u=2;u<r;u++)a[u]=n[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4094:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var o=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},a="How To Write Custom Interaction Behaviours?",s={unversionedId:"interactions/interaction-behaviours/custom-behaviours",id:"interactions/interaction-behaviours/custom-behaviours",title:"How To Write Custom Interaction Behaviours?",description:"If the default set of Interaction Behaviours does not suffice, you can easily add new useful behaviours for your",source:"@site/docs/03-interactions/03-interaction-behaviours/custom-behaviours.md",sourceDirName:"03-interactions/03-interaction-behaviours",slug:"/interactions/interaction-behaviours/custom-behaviours",permalink:"/docs/interactions/interaction-behaviours/custom-behaviours",draft:!1,editUrl:"https://github.com/realitycollective/com.realitytoolkit.docs/edit/main/docs/03-interactions/03-interaction-behaviours/custom-behaviours.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"UpdateRigidbodyBehaviour",permalink:"/docs/interactions/interaction-behaviours/default-behaviours/update-rigidbody-behaviour"},next:{title:"Samples",permalink:"/docs/category/samples"}},c={},u=[{value:"Writing Your First Interaction Behaviour",id:"writing-your-first-interaction-behaviour",level:2},{value:"Using Your Behaviour",id:"using-your-behaviour",level:2}],l={toc:u},d="wrapper";function p(e){let{components:t,...r}=e;return(0,i.kt)(d,(0,o.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"how-to-write-custom-interaction-behaviours"},"How To Write Custom Interaction Behaviours?"),(0,i.kt)("p",null,"If the default set of ",(0,i.kt)("inlineCode",{parentName:"p"},"Interaction Behaviour"),"s does not suffice, you can easily add new useful behaviours for your\n",(0,i.kt)("inlineCode",{parentName:"p"},"Interactable"),"s! The system is designed to be extendible and can be used to implement all kinds of specific app or game\nbehaviour."),(0,i.kt)("h2",{id:"writing-your-first-interaction-behaviour"},"Writing Your First Interaction Behaviour"),(0,i.kt)("p",null,"Create a new script in your project and name it ",(0,i.kt)("inlineCode",{parentName:"p"},"ForcePushBehaviour"),":"),(0,i.kt)("p",null,"Double click it to open it in your favourite code editor. You are now looking at an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"MonoBehaviour"),".\nClean it up and remove the default MonoBehaviour callbacks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"using UnityEngine;\n\npublic class ForcePushBehaviour : MonoBehaviour\n{\n    \n}\n")),(0,i.kt)("p",null,"Next we need to make sure that the component inherits ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseInteractionBehaviour"),".\nAdd"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"using RealityToolkit.Input.InteractionBehaviours;\n")),(0,i.kt)("p",null,"to the top of your script file and then make ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseInteractionBehaviour")," the base class of your component.\nThis is what your component should look like now:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"using RealityToolkit.Input.InteractionBehaviours;\nusing UnityEngine;\n\npublic class ForcePushBehaviour : BaseInteractionBehaviour\n{\n    \n}\n")),(0,i.kt)("p",null,"Next add a serialized private field to define the strength of your force push. Are you a Jedi Padawan just getting started\nor a powerful Jedi Master? Also make sure to get a reference to the interactable's rigidbody in your awake callback. Since we know\nthe interaction behaviour sits on the interactable object it is safe to assume that there is a rigidbody. Every Interactable object\nmust have a rigidbody. Your script looks like this now:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using RealityToolkit.Input.InteractionBehaviours;\nusing UnityEngine;\n\npublic class ForcePushBehaviour : BaseInteractionBehaviour\n{\n    [SerializeField, Tooltip("The power of the force push executed on the object.")]\n    private float forcePower = 10f;\n\n    private new Rigidbody rigidbody;\n\n    /// <inheritdoc/>\n    protected override void Awake()\n    {\n        base.Awake();\n        rigidbody = GetComponent<Rigidbody>();\n    }\n}\n')),(0,i.kt)("p",null,'Alright, we are almost there. All that is left to do now is make the component push away the interactable when we\nstop interacting with it. We will be using our custom behaviour together with some of the toolkit\'s default behaviours\nto grab the object and move it around and then when we "drop it", our force push should kick in and do its job.'),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Interaction Behaviours are meant to be combined where possible. Try combinging multiple behaviours to get the desired result.\nThat way we avoid monolithic behaviours that do a lot of things. Interaction Behaviours have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Sorting Order")," property that you can use\nto adjust their execution order, if needed. By default they will execute in the same order as they are attached to the ",(0,i.kt)("inlineCode",{parentName:"p"},"GameObject"),".")),(0,i.kt)("p",null,"Now back to work. Here is our completed ",(0,i.kt)("inlineCode",{parentName:"p"},"ForcePushBehaviour"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"using RealityToolkit.Input.Events;\nusing RealityToolkit.Input.InteractionBehaviours;\nusing RealityToolkit.Input.Interactors;\nusing UnityEngine;\n\npublic class ForcePushBehaviour : BaseInteractionBehaviour\n{\n    [SerializeField, Tooltip(\"The power of the force push executed on the object.\")]\n    private float forcePower = 10f;\n\n    private new Rigidbody rigidbody;\n\n    /// <inheritdoc/>\n    protected override void Awake()\n    {\n        base.Awake();\n        rigidbody = GetComponent<Rigidbody>();\n    }\n\n    /// <inheritdoc/>\n    protected override void OnLastGrabExited(InteractionExitEventArgs eventArgs)\n    {\n        base.OnLastGrabExited(eventArgs);\n\n        // This behaviour only works with controller based interactors.\n        if (eventArgs.Interactor is IControllerInteractor controllerInteractor)\n        {\n            // We determine the direction of our force push using the interactor's position in the scene\n            // and the interactable's position and normalize it.\n            var forceDirection = (transform.position - controllerInteractor.GameObject.transform.position).normalized;\n\n            // Scale by our configured force power.\n            forceDirection = forcePower * forceDirection;\n\n            // Finally add the force push to the rigidboy.\n            rigidbody.AddForce(forceDirection, ForceMode.Impulse);\n        }\n    }\n}\n")),(0,i.kt)("p",null,"Note how we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"OnLastGrabExited")," interaction event callback to do our magic. This callback is raised when the last interactor has released\ngrab input on the interctable. You could also listen for another custom input action to do the actual push but to keep things simple here, we simply consider\ndropping the object when we want to push it away."),(0,i.kt)("p",null,"Notice how we restrict the behaviour to only perform its duty if the interactor is a type of ",(0,i.kt)("inlineCode",{parentName:"p"},"IControllerInteractor")," because those are represented by a ",(0,i.kt)("inlineCode",{parentName:"p"},"GameObject"),"\nin the scene and thus have a position. We use that position to determine the direction of our force push."),(0,i.kt)("h2",{id:"using-your-behaviour"},"Using Your Behaviour"),(0,i.kt)("p",null,"Create a primitive ",(0,i.kt)("inlineCode",{parentName:"p"},"GameObject"),", such as a cube or sphere in your scene. Then attach the ",(0,i.kt)("inlineCode",{parentName:"p"},"Interactable")," component to it and also the ",(0,i.kt)("inlineCode",{parentName:"p"},"FocusLockBehaviour"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateRigidbodyBehaviour"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"TranslateBehaviour")," and the just created ",(0,i.kt)("inlineCode",{parentName:"p"},"ForcePushBehaviour"),". Configure the input events on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Interactable")," and make it only react to far interaction for simplicity, since our custom behaviour is not designed to work with direction interaction. Your GameObject configuration should look similar to this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Configured Interactable",src:n(4137).Z,width:"491",height:"309"})),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},'Once again, notice how we make use of the existing behaviours to perform the "telekinesis" aspect of our power.\nThe ',(0,i.kt)("inlineCode",{parentName:"p"},"FocusLockBehaviour")," makes sure that the interactor focus is kept on the interactable while we are interacting with it. After that the ",(0,i.kt)("inlineCode",{parentName:"p"},"UpdateRigidbodyBehaviour"),'\nmakes sure the Rigidbody is configured properly to discard gravity while we are "force holding" the object. ',(0,i.kt)("inlineCode",{parentName:"p"},"TranslateBehaviour")," performs the actual telekinesis and\nlast but not least our custom behaviour does the force push.")),(0,i.kt)("p",null,"Deploy to your device or use e.g. Quest Link to test using the editor and enjoy your new Jedi powers!"))}p.isMDXComponent=!0},4137:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/custom-behaviour-on-gameobject-be68ae9d7e58c55fddf8c94dfa2bf18e.png"}}]);